<!DOCTYPE html>
<!-- force redeploy -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Liga Fundão</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0f1221;
      --panel:#171a2b;
      --panel2:#1f2340;
      --ink:#e9ecff;
      --muted:#a7afd9;
      --accent:#7c9cff;
      --good:#11c27f;
      --bad:#ff6379;
      --border: #2a2f55;
      --chip:#2a2f55;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; padding:24px;
      background: radial-gradient(1200px 800px at 85% -10%, #223 0%, #0f1221 60%) no-repeat, var(--bg);
      color:var(--ink);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .wrap{max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;gap:16px;margin-bottom:20px}
    .logo{
      width:46px;height:46px;border-radius:12px;background:linear-gradient(135deg,#7c9cff, #9d7cff);
      box-shadow:var(--shadow);
      display:grid;place-items:center;font-weight:800;color:white;letter-spacing:.5px;
    }
    h1{font-size:28px;margin:0}
    .subtitle{color:var(--muted);margin-top:4px}
    .grid{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:900px){ .grid{grid-template-columns:1.2fr .8fr} }
    .panel{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border:1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow);
      padding:18px;
    }
    .panel h2{font-size:18px;margin:0 0 12px 0}
    .chips{display:flex;gap:10px;flex-wrap:wrap;margin:6px 0 2px}
    .chip{
      background:var(--chip); border:1px solid var(--border); color:var(--muted);
      padding:6px 10px; border-radius:999px; font-size:12px
    }
    table{width:100%; border-collapse:separate; border-spacing:0 10px}
    thead th{
      text-align:left; font-size:12px; letter-spacing:.04em; text-transform:uppercase; color:var(--muted);
      padding:8px 12px; cursor:pointer; user-select:none;
    }
    tbody td{
      background:rgba(255,255,255,.02); border-top:1px solid var(--border); border-bottom:1px solid var(--border);
      padding:12px; vertical-align:middle;
    }
    tbody tr td:first-child{
      border-left:1px solid var(--border); border-top-left-radius:10px; border-bottom-left-radius:10px;
      font-weight:600; color:#fff;
    }
    tbody tr td:last-child{
      border-right:1px solid var(--border); border-top-right-radius:10px; border-bottom-right-radius:10px;
    }
    .money{font-variant-numeric:tabular-nums}
    .right{text-align:right}
    .good{color:var(--good); font-weight:700}
    .bad{color:var(--bad); font-weight:700}
    .muted{color:var(--muted)}
    .totals{
      display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin-top:8px; margin-bottom:8px;
    }
    .kpi{
      background:rgba(255,255,255,.04); border:1px solid var(--border); border-radius:12px; padding:14px;
    }
    .kpi .label{font-size:12px; color:var(--muted)}
    .kpi .value{font-size:20px; font-weight:700; margin-top:6px}
    .small{font-size:12px}
    .footer-note{margin-top:10px;color:var(--muted);font-size:12px}
    .pill{
      display:inline-block; padding:4px 8px; border-radius:999px; font-size:11px; background:#28305e; color:#b8c2ff; border:1px solid var(--border)
    }
    .rank-wrap{width:100%;height:auto;aspect-ratio: 5 / 2; background:rgba(255,255,255,.02); border:1px solid var(--border); border-radius:12px}
    .rank-axis{stroke:#3a3f6b; stroke-width:1}
    .rank-grid{stroke:#2a2f55; stroke-width:.8; opacity:.65}
    .rank-label{fill:var(--muted); font-size:14px}
    .rank-badge{font-size:14px; font-weight:600; fill:#fff; dominant-baseline:middle; text-anchor:middle; pointer-events:none}
    #gw-selector {
  font-size: 15px !important;
  font-weight: 600 !important;
  padding: 8px 14px !important;
  border-radius: 8px !important;
  border: 2px solid var(--accent) !important;
  background: var(--panel2) !important;
  color: var(--ink) !important;
  cursor: pointer !important;
  transition: all 0.2s ease !important;
}

#gw-selector:hover {
  background: var(--accent) !important;
  color: #fff !important;
}
#summary-table tbody td:not(:first-child),
#summary-table thead th:not(:first-child),
#weeks table tbody td:not(:first-child),
#weeks table thead th:not(:first-child) {
  text-align: center;
}

/* --- GW Heatmap --- */
#gw-heatmap svg { width: 100%; height: auto; display: block; }
.hm-axis { fill: var(--muted); font-size: 12px; }
.hm-score { fill: #fff; font-size: 12px; font-weight: 600; text-anchor: middle; dominant-baseline: central; }
.hm-top { stroke: #fff; stroke-width: 2; }
.hm-legend text { fill: var(--muted); font-size: 12px; }
@media (max-width: 700px) {
  .hm-axis { font-size: 9px; }
  .hm-score { font-size: 9px; }
}

  </style>
</head>
<body>
<div class="wrap">
<header>
  <img src="assets/LF.png" alt="Liga Fundão crest" style="width:80px;height:auto;margin-right:12px;">
  <div>
    <h1>LIGA FUNDÃO</h1>
    <div class="chips">
      <span class="chip" id="cpp-chip"></span>
    </div>
  </div>
</header>

  <div class="grid">
    <!-- Summary -->
    <section class="panel">
      <h2>Global</h2>
      <div class="totals" id="league-kpis"></div>
      <table id="summary-table">
        <thead>
          <tr>
            <th data-key="player">Jogador</th>
            <th class="right" data-key="totalScore">Pontos*</th>
            <th class="right" data-key="paid">Pago</th>
            <th class="right" data-key="owed">Dívida</th>
            <th class="right" data-key="balance">Saldo</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="footer-note">
        *Pontos nesta tabela já incluem a penalização das transferências.
          Saldo = Dívida − Pago. 
          A dívida é calculada com a diferença de pontos para o melhor classificado da jornada e penalizações das transferências.
      </div>
    </section>

    <!-- Per-Week Scoreboards -->
    <section class="panel">
      <h2 style="margin-bottom: 12px;">
        Tabelas por Jornada
        <select id="gw-selector" style="margin-left:12px; background:var(--panel2); color:var(--ink); border:1px solid var(--border); border-radius:6px; padding:4px 8px;">
          <option value="">Todas</option>
        </select>
      </h2>
      <div id="weeks"></div>
      <div class="footer-note"> A melhor pontuação não paga nada; Todos os outros devem. <span class="pill">(Melhor Pontuação − (Pontuação − Transferências)) × Custo por Ponto</span>.</div>
    </section>

    <section class="panel" style="grid-column:1 / -1;">
        <h2>Evolução das Classificações</h2>
        <div id="rank-chart-wrap" class="rank-wrap">
        <svg id="rank-chart" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
        <div class="footer-note small">Desempates: menor número de transferências, ordem alfabética.

          <section class="panel" style="grid-column:1 / -1;">
          <h2>Performance Semanal<span class="pill">Pontos - Transferências</span></h2>
            <div id="gw-heatmap"></div>
              <div class="footer-note small">As células são coloridas de valores baixos (vermelho) até altos (verde). Branco mostra o melhor de cada jornada.</div>
            </section>


  </div>
</div>

<script>
  // ========= EDIT YOUR DATA BELOW (mirrors your Python script) =========

  const PLAYERS = ["Diogo Lopes", "Bernardo Saraiva", "Rui Bimba", "Miguel Antunes", "Diogo Amarelo", "Joao Leitao"];

  // One entry per GW. Keys can be "GW1", "GW2", etc. Scores must be per-player.
  const MATCHWEEKS = {
    "GW1": {"Diogo Lopes": 70, "Bernardo Saraiva": 50, "Rui Bimba": 50, "Miguel Antunes": 49, "Diogo Amarelo": 46, "Joao Leitao": 39},
    "GW2": {"Diogo Lopes": 59, "Bernardo Saraiva": 50, "Rui Bimba": 32, "Miguel Antunes": 33, "Diogo Amarelo": 52, "Joao Leitao": 43},
    "GW3": {"Diogo Lopes": 59, "Bernardo Saraiva": 47, "Rui Bimba": 72, "Miguel Antunes": 53, "Diogo Amarelo": 37, "Joao Leitao": 46},
    // "GW3": {...}
  };

  // NEW: Transfers per GW per player (points to deduct). Missing = 0.
  const TRANSFERS = {
    "GW1": {"Diogo Lopes": 0, "Bernardo Saraiva": 0, "Rui Bimba": 0, "Miguel Antunes": 0, "Diogo Amarelo": 0, "Joao Leitao": 0},
    "GW2": {"Diogo Lopes": 0, "Bernardo Saraiva": 0, "Rui Bimba": 0, "Miguel Antunes": 0, "Diogo Amarelo": 12, "Joao Leitao": 0},
    "GW3": {"Diogo Lopes": 0, "Bernardo Saraiva": 8, "Rui Bimba": 0, "Miguel Antunes": 0, "Diogo Amarelo": 4, "Joao Leitao": 0},
    // "GW3": {...}
  };

  // Cost per point (EUR)
  const COST_PER_POINT = 0.05;

  // Manual payments (EUR) made so far by each player (optional)
  const MANUAL_PAYMENTS = {
    "Diogo Lopes": 0.65,
    "Diogo Amarelo": 4.1,
    "Bernardo Saraiva": 3.1,
    "Miguel Antunes": 3.3,
    "Rui Bimba": 2.35,
  };

  // ========= END OF DATA SECTION =========

  // Helpers
  const euro = new Intl.NumberFormat('pt-PT', {style:'currency', currency:'EUR'});
  const round2 = x => Math.round(x * 100) / 100;

  function safeTransfer(gw, p){
    const t = TRANSFERS?.[gw]?.[p];
    return Number.isFinite(t) ? t : 0;
  }

// --- Helpers for rank chart ---
const getInitials = name =>
  name.split(' ').map(w=>w[0]).join('').slice(0,3).toUpperCase();

function sortGWsNumeric(keys){
  return keys.slice().sort((a,b)=>parseInt(a.replace(/\D/g,'')) - parseInt(b.replace(/\D/g,'')));
}

function distinctColors(n){
  // evenly spaced hues; no custom colors set elsewhere
  return Array.from({length:n}, (_,i)=>`hsl(${Math.round((360/n)*i)}, 70%, 60%)`);
}

function compute() {
  // Precompute per-week top NET score (score - transfers)
  const weekTops = {};
  for (const [gw, scores] of Object.entries(MATCHWEEKS)) {
    let top = -Infinity;
    for (const p of PLAYERS) {
      const s = (scores && Number.isFinite(scores[p])) ? scores[p] : 0;
      const t = safeTransfer(gw, p);
      const net = s - t;
      if (net > top) top = net;
    }
    weekTops[gw] = top === -Infinity ? 0 : top;
  }

  // Per-player aggregates
  const rows = PLAYERS.map(p => {
    let totalScoreNet = 0;
    let totalTransfers = 0;
    let totalOwed = 0;

    for (const [gw, scores] of Object.entries(MATCHWEEKS)) {
      const s = (scores && Number.isFinite(scores[p])) ? scores[p] : 0;
      const t = safeTransfer(gw, p);
      const net = s - t;

      totalScoreNet += net;
      totalTransfers += t;

      // Debt per week now uses NET scores
      const diff = Math.max(0, (weekTops[gw] ?? 0) - net);
      const weeklyDebt = round2(diff * COST_PER_POINT);
      totalOwed = round2(totalOwed + weeklyDebt);
    }

    const paid = round2(MANUAL_PAYMENTS[p] ?? 0);
    const balance = round2(totalOwed - paid);

    return { player: p, totalScore: totalScoreNet, totalTransfers, owed: totalOwed, paid, balance };
  });

  // League KPIs
  const totalPaidAll = rows.reduce((a,r)=>a+r.paid,0);
  const totalOwedAll = rows.reduce((a,r)=>a+r.owed,0);
  const totalBalanceAll = round2(totalOwedAll - totalPaidAll);

  return { rows, weekTops, totals: {
    paid: round2(totalPaidAll),
    owed: round2(totalOwedAll),
    balance: totalBalanceAll,
    gws: Object.keys(MATCHWEEKS).length
  }};
}

  function renderKPIs(kpis){
    const el = document.getElementById('league-kpis');
    el.innerHTML = `
      <div class="kpi">
        <div class="label">Jornadas</div>
        <div class="value">${kpis.gws}</div>
      </div>
      <div class="kpi">
        <div class="label">Dívida Total</div>
        <div class="value money">${euro.format(kpis.owed)}</div>
      </div>
      <div class="kpi">
        <div class="label">Total Pago</div>
        <div class="value money">${euro.format(kpis.paid)}</div>
      </div>
    `;
  }

  function renderSummary(rows){
    const tbody = document.querySelector('#summary-table tbody');
    tbody.innerHTML = "";
    rows.forEach(r=>{
      const balClass = r.balance <= 0 ? 'good' : 'bad'; // <= 0 means settled or ahead
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.player}</td>
        <td class="right">${r.totalScore}</td>
        <td class="right money">${euro.format(r.paid)}</td>
        <td class="right money">${euro.format(r.owed)}</td>
        <td class="right money ${balClass}">${euro.format(r.balance)}</td>
      `;
      tbody.appendChild(tr);
    });
  }
function renderWeeks(weekTops){
  const wrapper = document.getElementById('weeks');
  wrapper.innerHTML = "";

  const gwSelector = document.getElementById('gw-selector');
  const selectedGW = gwSelector?.value || "";

  const weeks = Object.keys(MATCHWEEKS);
  if (weeks.length === 0) {
    wrapper.innerHTML = `<div class="muted small">No gameweeks yet. Add them in the data section of the file.</div>`;
    return;
  }

  const toRender = selectedGW ? [selectedGW] : weeks;

  toRender.forEach(gw => {
    const scores = MATCHWEEKS[gw] || {};
    const topNet = weekTops[gw] ?? 0;

    const rows = PLAYERS.map(p => {
      const score = Number.isFinite(scores[p]) ? scores[p] : 0;
      const transfers = safeTransfer(gw, p);
      const net = score - transfers;
      return { player: p, score, transfers, net };
    })
    // Show by original score (unchanged), but debts & top use NET
    .sort((a, b) => b.score - a.score);

    const table = document.createElement('table');
    table.innerHTML = `
      <thead>
        <tr>
          <th>${gw}</th>
          <th class="right">Pontos</th>
          <th class="right">Transferências</th>
          <th class="right">Diferença</th>
          <th class="right">Dívida</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r => {
          const diff = -Math.max(0, topNet - r.net);      // now NET
          const debt = -round2(diff * COST_PER_POINT);    // now NET
          const isTop = r.net === topNet;                // top by NET
          const badge = isTop ? ` <span class="pill">Top</span>` : "";
          const transfersCell = r.transfers > 0 ? `-${r.transfers}` : '0';
          return `
            <tr>
              <td>${r.player}${badge}</td>
              <td class="right">${r.score}</td>
              <td class="right">${transfersCell}</td>
              <td class="right">${isTop ? '—' : diff}</td>
              <td class="right money ${isTop ? 'good' : ''}">${isTop ? '—' : euro.format(debt)}</td>
            </tr>
          `;
        }).join("")}
      </tbody>
    `;

    const panel = document.createElement('div');
    panel.className = 'kpi';
    panel.style.padding = 0;
    panel.style.overflow = 'hidden';

    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    header.style.padding = '12px 14px';
    header.style.borderBottom = '1px solid var(--border)';
    header.innerHTML = `<div><strong>${gw}</strong> <span class="muted small">Melhor Pontuação: ${topNet}</span></div>
                        <div class="pill">Custo/pt: ${euro.format(COST_PER_POINT)}</div>`;
    
    const inner = document.createElement('div');
    inner.style.padding = '6px 10px 12px';
    inner.appendChild(table);

    panel.appendChild(header);
    panel.appendChild(inner);
    wrapper.appendChild(panel);
  });
}

  // Simple table sort on click (client-side)
  function enableSorting(dataRows){
    const headers = document.querySelectorAll('#summary-table thead th');
    let current = {key:'balance', dir:'asc'};

    function renderSorted(){
      const rows = [...dataRows];
      rows.sort((a,b)=>{
        const k = current.key;
        const av = a[k], bv = b[k];
        if (typeof av === 'string') return current.dir==='asc' ? av.localeCompare(bv) : bv.localeCompare(av);
        return current.dir==='asc' ? av - bv : bv - av;
      });
      renderSummary(rows);
    }

    headers.forEach(th=>{
      th.addEventListener('click', ()=>{
        const key = th.getAttribute('data-key');
        if(!key) return;
        current.dir = (current.key === key && current.dir === 'asc') ? 'desc' : 'asc';
        current.key = key;
        renderSorted();
      });
    });

    // Initial sort by Total Score (descending)
    current = {key:'totalScore', dir:'desc'};
    renderSorted();
  }

function buildCumulativeSeries(){
  const gws = sortGWsNumeric(Object.keys(MATCHWEEKS));
  const series = {}; // per player: {color, points:[...], transfers:[...], ranks:[...]}
  const colors = distinctColors(PLAYERS.length);
  PLAYERS.forEach((p,i)=>{ series[p] = { color: colors[i], points:[], transfers:[], ranks:[] }; });

  let cumPts = Object.fromEntries(PLAYERS.map(p=>[p,0]));
  let cumTrf = Object.fromEntries(PLAYERS.map(p=>[p,0]));

  gws.forEach(gw=>{
    PLAYERS.forEach(p=>{
      const s = Number.isFinite(MATCHWEEKS[gw]?.[p]) ? MATCHWEEKS[gw][p] : 0;
      const t = Number.isFinite(TRANSFERS?.[gw]?.[p]) ? TRANSFERS[gw][p] : 0;
      cumPts[p] += (s - t);
      cumTrf[p] += t;
      series[p].points.push(cumPts[p]);
      series[p].transfers.push(cumTrf[p]);
    });

    // ranks for this GW using tie-breakers
    const order = PLAYERS.slice().sort((a,b)=>{
      if (cumPts[b] !== cumPts[a]) return cumPts[b] - cumPts[a];              // more points better
      if (cumTrf[a] !== cumTrf[b]) return cumTrf[a] - cumTrf[b];              // fewer transfers better
      return a.localeCompare(b);                                              // stable
    });

    const rankMap = Object.fromEntries(order.map((p,idx)=>[p, idx+1])); // 1-based rank
    PLAYERS.forEach(p=> series[p].ranks.push(rankMap[p]));
  });

  return { gws: sortGWsNumeric(Object.keys(MATCHWEEKS)), series };
}

function renderRankChart(){
  const svg = document.getElementById('rank-chart');
  if(!svg) return;
  const { gws, series } = buildCumulativeSeries();
  const W = 1000, H = 600;   // viewBox size
  const rMarker = 18; // circle radius
  const xPad = rMarker + 8;
  const yPad = rMarker + 6;
  const margin = { left: 72, right: 28, top: 16, bottom: 64 };
  const innerW = W - margin.left - margin.right;
  const innerH = H - margin.top - margin.bottom;

  // Clear
  while(svg.firstChild) svg.removeChild(svg.firstChild);

  // Root group
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
  svg.appendChild(g);

  const nG = gws.length;
  if (nG === 0) {
    const txt = document.createElementNS(svg.namespaceURI,'text');
    txt.textContent = 'Add gameweeks to see rank evolution';
    txt.setAttribute('x', W/2); txt.setAttribute('y', H/2);
    txt.setAttribute('text-anchor','middle'); txt.setAttribute('fill','var(--muted)');
    svg.appendChild(txt);
    return;
  }

  // Scales
 
  const maxRank = PLAYERS.length;
  const xFor = i => {
  if (nG <= 1) return innerW / 2; // single-GW fallback
  const span = innerW - 2 * xPad;
  return xPad + i * (span / (nG - 1));
};
const yFor = r => {
  if (maxRank <= 1) return innerH / 2;
  const span = innerH - 2 * yPad;
  return yPad + (r - 1) * (span / (maxRank - 1));
};

  // Grid + axes
  // horizontal lines for ranks
  for(let r=1; r<=maxRank; r++){
    const y = yFor(r);
    const line = document.createElementNS(svg.namespaceURI,'line');
    line.setAttribute('x1', 0); line.setAttribute('y1', y);
    line.setAttribute('x2', innerW); line.setAttribute('y2', y);
    line.setAttribute('class','rank-grid');
    g.appendChild(line);

    const lab = document.createElementNS(svg.namespaceURI,'text');
    lab.textContent = `#${r}`;
    lab.setAttribute('x', -8); lab.setAttribute('y', y+4);
    lab.setAttribute('class','rank-label'); lab.setAttribute('text-anchor','end');
    g.appendChild(lab);
  }

    // x labels (GWs)
    // x labels (GWs)
    gws.forEach((gw,i)=>{
    const x = xFor(i);

    const tick = document.createElementNS(svg.namespaceURI,'line');
    tick.setAttribute('x1', x);
    tick.setAttribute('y1', innerH);
    tick.setAttribute('x2', x);
    tick.setAttribute('y2', innerH + 6);
    tick.setAttribute('class','rank-axis');
    g.appendChild(tick);

    const lab = document.createElementNS(svg.namespaceURI,'text');
    lab.textContent = gw;
    lab.setAttribute('x', x);
    lab.setAttribute('y', innerH + 22);   // was +20
    lab.setAttribute('class','rank-label');
    lab.setAttribute('text-anchor','middle');
    g.appendChild(lab);
    });


  // Build positions and detect same-spot overlaps to offset markers
  const positionsAt = Array.from({length:nG}, ()=>({})); // [{ 'rank@i': [players...] }, ...]
  PLAYERS.forEach(p=>{
    const ranks = series[p].ranks;
    ranks.forEach((r,i)=>{
      const key = `${r}`;
      if(!positionsAt[i][key]) positionsAt[i][key] = [];
      positionsAt[i][key].push(p);
    });
  });

  // Draw lines first (behind markers)
  PLAYERS.forEach(p=>{
    const ranks = series[p].ranks;
    const color = series[p].color;
    const path = document.createElementNS(svg.namespaceURI,'path');
    let d = '';
    ranks.forEach((r,i)=>{
      const x = xFor(i), y = yFor(r);
      d += (i===0 ? `M ${x},${y}` : ` L ${x},${y}`);
    });
    path.setAttribute('d', d);
    path.setAttribute('fill','none');
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width','2.5');
    g.appendChild(path);
  });

  // Markers with initials (offset if multiple at same spot)

  gws.forEach((gw,i)=>{
    const buckets = positionsAt[i]; // { 'rank': [players...] }
    Object.entries(buckets).forEach(([rankKey, playersHere])=>{
      const r = parseInt(rankKey,10);
      const y = yFor(r);
      const count = playersHere.length;
      const spread = Math.min(18, 10 + (count-1)*6); // cap overall spread
      const offsets = playersHere.map((_,idx)=>{
        if (count === 1) return 0;
        const start = -spread/2, step = spread/(count-1 || 1);
        return start + idx*step;
      });

      playersHere.forEach((p,idx)=>{
        const x = xFor(i) + offsets[idx];
        const color = series[p].color;

        const circ = document.createElementNS(svg.namespaceURI,'circle');
        circ.setAttribute('cx', x); circ.setAttribute('cy', y);
        circ.setAttribute('r', rMarker);
        circ.setAttribute('fill', color);
        circ.setAttribute('stroke', '#0b0e1d');
        circ.setAttribute('stroke-width', '3');
        g.appendChild(circ);

        const text = document.createElementNS(svg.namespaceURI,'text');
        text.textContent = getInitials(p);
        text.setAttribute('x', x); text.setAttribute('y', y+1);
        text.setAttribute('class','rank-badge');
        g.appendChild(text);
      });
    });
  });


}


// ----- Heatmap data builder (NET scores) -----
function buildHeatmapData(){
  const gws = sortGWsNumeric(Object.keys(MATCHWEEKS));
  const data = [];                       // rows = players, cols = gws
  const topIdxPerGW = {};                // { gw: rowIndex }
  let vMin = Infinity, vMax = -Infinity;

  // compute per-GW top NET
  const weekTopNet = {};
  gws.forEach(gw => {
    let top = -Infinity;
    PLAYERS.forEach(p => {
      const s = Number.isFinite(MATCHWEEKS[gw]?.[p]) ? MATCHWEEKS[gw][p] : 0;
      const t = Number.isFinite(TRANSFERS?.[gw]?.[p]) ? TRANSFERS[gw][p] : 0;
      const net = s - t;
      if (net > top) top = net;
    });
    weekTopNet[gw] = top === -Infinity ? 0 : top;
  });

  // matrix + global min/max + top index by GW
  PLAYERS.forEach((p, rowIdx) => {
    const row = [];
    gws.forEach(gw => {
      const s = Number.isFinite(MATCHWEEKS[gw]?.[p]) ? MATCHWEEKS[gw][p] : 0;
      const t = Number.isFinite(TRANSFERS?.[gw]?.[p]) ? TRANSFERS[gw][p] : 0;
      const net = s - t;
      row.push(net);
      vMin = Math.min(vMin, net);
      vMax = Math.max(vMax, net);
      if (net === weekTopNet[gw]) topIdxPerGW[gw] = rowIdx;
    });
    data.push(row);
  });

  return { gws, data, vMin: vMin === Infinity ? 0 : vMin, vMax: vMax === -Infinity ? 0 : vMax, topIdxPerGW };
}

// ----- Color scale: red (low) -> green (high), via hue interpolation -----
function heatColor(v, vMin, vMax){
  if (vMax === vMin) return 'hsl(200, 10%, 35%)'; // flat case
  const t = (v - vMin) / (vMax - vMin);           // 0..1
  const hue = 10 + t * 120;                       // 10=red-ish -> 130=green
  const sat = 70, light = 45;
  return `hsl(${hue}, ${sat}%, ${light}%)`;
}

// ----- Render heatmap into #gw-heatmap -----
function renderHeatmap(){
  const root = document.getElementById('gw-heatmap');
  if (!root) return;
  root.innerHTML = '';

  const { gws, data, vMin, vMax, topIdxPerGW } = buildHeatmapData();
  const rows = PLAYERS.length, cols = gws.length;

  // SVG layout
  const cellW = 70, cellH = 28;
  const leftPad = 64;   // was 140
  const topPad = 24;    // was 28
  const rightPad = 12;  // was 16
  const bottomPad = 24; // no legend, so smaller
  const W = leftPad + cols * cellW + rightPad;
  const H = topPad + rows * cellH + bottomPad;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

  // Col labels (GWs)
  gws.forEach((gw, c) => {
    const x = leftPad + c * cellW + cellW/2;
    const y = topPad - 8;
    const text = document.createElementNS(svg.namespaceURI, 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y);
    text.setAttribute('class', 'hm-axis');
    text.setAttribute('text-anchor', 'middle');
    text.textContent = gw;
    svg.appendChild(text);
  });

// Row labels (Players)
  PLAYERS.forEach((p, r) => {
    const x = leftPad - 10;
    const y = topPad + r * cellH + cellH/2 + 1;
    const text = document.createElementNS(svg.namespaceURI, 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y);
    text.setAttribute('class', 'hm-axis');
    text.setAttribute('text-anchor', 'end');
    text.textContent = getInitials(p);   // <-- use initials
    svg.appendChild(text);
  });

  // Cells
  for (let r = 0; r < rows; r++){
    for (let c = 0; c < cols; c++){
      const v = data[r][c];
      const x = leftPad + c * cellW;
      const y = topPad + r * cellH;
      const rect = document.createElementNS(svg.namespaceURI, 'rect');
      rect.setAttribute('x', x);
      rect.setAttribute('y', y);
      rect.setAttribute('width', cellW-2);
      rect.setAttribute('height', cellH-2);
      rect.setAttribute('rx', 4);
      rect.setAttribute('fill', heatColor(v, vMin, vMax));
      if (topIdxPerGW[gws[c]] === r) rect.setAttribute('class','hm-top');
      rect.setAttribute('opacity','0.95');
      rect.appendChild(document.createElementNS(svg.namespaceURI, 'title'))
           .textContent = `${PLAYERS[r]} • ${gws[c]}: ${v}`;
      svg.appendChild(rect);

      // Score text (kept compact for readability)
      const label = document.createElementNS(svg.namespaceURI, 'text');
      label.setAttribute('x', x + (cellW-2)/2);
      label.setAttribute('y', y + (cellH-2)/2 + 1);
      label.setAttribute('class', 'hm-score');
      label.textContent = v;
      svg.appendChild(label);
    }
  }

/*   // Legend
  const lgX = leftPad, lgY = topPad + rows * cellH + 18, lgW = Math.max(160, Math.min(320, cols * cellW));
  const steps = 40;
  for (let i=0;i<steps;i++){
    const t = i/(steps-1);
    const v = vMin + t*(vMax - vMin);
    const rr = document.createElementNS(svg.namespaceURI, 'rect');
    rr.setAttribute('x', lgX + t*lgW);
    rr.setAttribute('y', lgY);
    rr.setAttribute('width', lgW/steps + 1);
    rr.setAttribute('height', 10);
    rr.setAttribute('fill', heatColor(v, vMin, vMax));
    svg.appendChild(rr);
  }
  const tMin = document.createElementNS(svg.namespaceURI, 'text');
  tMin.setAttribute('x', lgX); tMin.setAttribute('y', lgY + 24);
  tMin.setAttribute('class','hm-legend');
  tMin.textContent = vMin;
  svg.appendChild(tMin);

  const tMax = document.createElementNS(svg.namespaceURI, 'text');
  tMax.setAttribute('x', lgX + lgW); tMax.setAttribute('y', lgY + 24);
  tMax.setAttribute('text-anchor','end');
  tMax.setAttribute('class','hm-legend');
  tMax.textContent = vMax;
  svg.appendChild(tMax);*/

  root.appendChild(svg);
} 


  // Boot
(function init(){
  document.getElementById('cpp-chip').textContent = `Custo por ponto: ${euro.format(COST_PER_POINT)}`;
  const {rows, weekTops, totals} = compute();
  renderKPIs(totals);
  enableSorting(rows);

  const gwSelector = document.getElementById('gw-selector');
  if (gwSelector) {
    // sort GWs numerically so "GW10" doesn't come before "GW2"
    const gws = Object.keys(MATCHWEEKS).sort(
      (a,b)=>parseInt(a.replace(/\D/g,'')) - parseInt(b.replace(/\D/g,''))
    );

    // (re)populate options
    gwSelector.innerHTML = '<option value="">Todas</option>';
    gws.forEach(gw => {
      const opt = document.createElement('option');
      opt.value = gw;
      opt.textContent = gw;
      gwSelector.appendChild(opt);
    });

    // default to the latest GW
    if (gws.length) gwSelector.value = gws[gws.length - 1];

    gwSelector.addEventListener('change', () => renderWeeks(weekTops));
  }

  // render after the selector is set so the latest GW shows by default
  renderWeeks(weekTops);
  renderRankChart();
  renderHeatmap();  
})();

</script>
</body>
</html>
